// üéØ ROZWIƒÑZANIE PROBLEMU: "Czy endpoint zadzia≈Ça?"
// Apache Camel + Groovy - Walidacja przed startem

@Grab('org.apache.camel:camel-core:3.20.0')
@Grab('org.apache.camel:camel-file:3.20.0')
@Grab('org.apache.camel:camel-ftp:3.20.0')
@Grab('org.apache.camel:camel-mail:3.20.0')
@Grab('org.apache.camel:camel-http:3.20.0')

import org.apache.camel.*
import org.apache.camel.builder.RouteBuilder
import org.apache.camel.impl.DefaultCamelContext
import org.apache.camel.spi.EndpointRegistry

// üîß ENV CONFIG LOADER
class EnvConfigLoader {
    static Map<String, String> config = [:]

    static void loadEnvFile(String envFile = '.env') {
        def file = new File(envFile)
        if (!file.exists()) {
            println "‚ö†Ô∏è  Plik ${envFile} nie istnieje - u≈ºywam zmiennych systemowych"
            return
        }

        file.eachLine { line ->
            line = line.trim()
            if (line && !line.startsWith('#') && line.contains('=')) {
                def parts = line.split('=', 2)
                def key = parts[0].trim()
                def value = parts[1].trim().replaceAll(/^["']|["']$/, '') // usu≈Ñ cudzys≈Çowy
                config[key] = value
                System.setProperty(key, value) // ustaw jako system property
            }
        }
        println "‚úÖ Za≈Çadowano ${config.size()} zmiennych z ${envFile}"
    }

    static String get(String key, String defaultValue = null) {
        return System.getProperty(key) ?: System.getenv(key) ?: config[key] ?: defaultValue
    }

    static String resolveEndpoint(String endpoint) {
        // Zamie≈Ñ ${VAR} na warto≈õci ze zmiennych
        return endpoint.replaceAll(/\$\{([^}]+)\}/) { match, varName ->
            get(varName, "\${${varName}}")
        }
    }
}

// üîç KLASA DO WALIDACJI ENDPOINT√ìW
class EndpointValidator {

    CamelContext camelContext

    EndpointValidator(CamelContext context) {
        this.camelContext = context
    }

    // üìã SPRAWD≈π WSZYSTKIE ENDPOINTY PRZED STARTEM
    Map<String, String> validateAllEndpoints(List<String> endpointUris) {
        def results = [:]

        endpointUris.each { uri ->
            results[uri] = validateSingleEndpoint(uri)
        }

        return results
    }

    // üîç WALIDACJA POJEDYNCZEGO ENDPOINTU Z ENV SUPPORT
    String validateSingleEndpoint(String uri) {
        try {
            // Rozwi≈Ñ zmienne ≈õrodowiskowe
            def resolvedUri = EnvConfigLoader.resolveEndpoint(uri)
            println "üîç Sprawdzam: ${uri}"
            if (uri != resolvedUri) {
                println "   ‚Ü≥ Rozwiniƒôty: ${resolvedUri}"
            }

            // Sprawd≈∫ czy mo≈ºna utworzyƒá endpoint
            Endpoint endpoint = camelContext.getEndpoint(resolvedUri)

            // Sprawd≈∫ specyficzne dla typu
            def type = getEndpointType(resolvedUri)
            switch(type) {
                case 'file': return validateFileEndpoint(resolvedUri)
                case ['ftp','sftp']: return validateFtpEndpoint(resolvedUri)
                case ['http','https']: return validateHttpEndpoint(resolvedUri)
                case ['smtp','smtps','pop3','imap']: return validateSmtpEndpoint(resolvedUri)
                case ['jms','activemq','rabbitmq']: return validateJmsEndpoint(resolvedUri)
                case ['jdbc','sql']: return validateJdbcEndpoint(resolvedUri)
                case 'kafka': return validateKafkaEndpoint(resolvedUri)
                case ['websocket','netty','mina']: return validateNetworkEndpoint(resolvedUri)
                case ['ldap','ldaps']: return validateSocketEndpoint(resolvedUri, ~/ldaps?:\/\/([^\/]+)/, '389', 'LDAP')
                case 'mongodb': return validateSocketEndpoint(resolvedUri, ~/mongodb:\/\/([^\/]+)/, '27017', 'MongoDB')
                case 'redis': return validateSocketEndpoint(resolvedUri, ~/redis:\/\/([^\/]+)/, '6379', 'Redis')
                default: return validateGenericEndpoint(endpoint)
            }

        } catch (Exception e) {
            return "‚ùå B≈ÅƒÑD: ${e.message}"
        }
    }

    // üìÅ WALIDACJA ENDPOINT FILE
    String validateFileEndpoint(String uri) {
        def path = extractPath(uri, 'file:')
        def file = new File(path)

        if (!file.exists()) {
            if (uri.contains('?autoCreate=true')) {
                file.mkdirs()
                return "‚úÖ Folder utworzony: ${path}"
            } else {
                return "‚ùå Folder nie istnieje: ${path}"
            }
        }

        if (!file.canRead()) return "‚ùå Brak uprawnie≈Ñ odczytu: ${path}"
        if (uri.contains('moveFailed') && !file.canWrite()) {
            return "‚ùå Brak uprawnie≈Ñ zapisu: ${path}"
        }

        return "‚úÖ File endpoint OK: ${path}"
    }

    // üåê WALIDACJA HTTP ENDPOINT
    String validateHttpEndpoint(String uri) {
        try {
            def url = new URL(uri.replace('http:', 'http://').replace('https:', 'https://'))
            def connection = url.openConnection()
            connection.setConnectTimeout(5000)
            connection.setRequestMethod('HEAD')

            def responseCode = connection.responseCode

            if (responseCode >= 200 && responseCode < 400) {
                return "‚úÖ HTTP endpoint OK: ${responseCode}"
            } else {
                return "‚ö†Ô∏è HTTP endpoint zwraca: ${responseCode}"
            }

        } catch (Exception e) {
            return "‚ùå HTTP endpoint nieosiƒÖgalny: ${e.message}"
        }
    }

    // üìß WALIDACJA SMTP/MAIL ENDPOINTS
    String validateSmtpEndpoint(String uri) {
        return validateSocketEndpoint(uri, ~/smtp:\/\/([^:]+):?(\d+)?/, '25', 'SMTP')
    }

    // üì° WALIDACJA FTP/SFTP ENDPOINTS
    String validateFtpEndpoint(String uri) {
        def port = uri.startsWith('sftp:') ? '22' : '21'
        def protocol = uri.startsWith('sftp:') ? 'SFTP' : 'FTP'
        return validateSocketEndpoint(uri, ~/(s?ftp):\/\/([^\/]+)/, port, protocol)
    }

    // üîå WALIDACJA SOCKET-BASED ENDPOINTS
    String validateSocketEndpoint(String uri, pattern, defaultPort, protocol) {
        try {
            def matcher = uri =~ pattern
            if (matcher.find()) {
                def host = matcher.group(matcher.groupCount()).split(':')[0]
                def port = uri.contains(':' + host + ':') ?
                    uri.split(':' + host + ':')[1].split('[/?]')[0] : defaultPort

                new Socket().withCloseable { socket ->
                    socket.connect(new InetSocketAddress(host, port as Integer), 5000)
                }
                return "‚úÖ ${protocol} server: ${host}:${port}"
            }
        } catch (Exception e) {
            return "‚ùå ${protocol} error: ${e.message.take(50)}"
        }
        return "‚ùå Invalid ${protocol} format"
    }

    // üíæ WALIDACJA DATABASE ENDPOINTS
    String validateJdbcEndpoint(String uri) {
        def drivers = ['h2':'org.h2.Driver', 'mysql':'com.mysql.jdbc.Driver',
                       'postgresql':'org.postgresql.Driver', 'oracle':'oracle.jdbc.OracleDriver']
        def dbType = uri.split(':')[1]
        return drivers[dbType] ? "‚úÖ DB driver available: ${dbType}" : "‚ùå DB driver missing: ${dbType}"
    }

    // ‚ö° WALIDACJA JMS/ACTIVEMQ ENDPOINTS
    String validateJmsEndpoint(String uri) {
        if (uri.contains('activemq:')) return validateSocketEndpoint(uri, ~/tcp:\/\/([^:]+):?(\d+)?/, '61616', 'ActiveMQ')
        if (uri.contains('rabbitmq:')) return validateSocketEndpoint(uri, ~/([^:]+):?(\d+)?/, '5672', 'RabbitMQ')
        return "‚ö†Ô∏è JMS broker validation needed"
    }

    // üìä WALIDACJA KAFKA ENDPOINTS
    String validateKafkaEndpoint(String uri) {
        return validateSocketEndpoint(uri, ~/kafka:([^?]+)/, '9092', 'Kafka')
    }

    // üåê WALIDACJA WEBSOCKET/TCP ENDPOINTS
    String validateNetworkEndpoint(String uri) {
        if (uri.startsWith('websocket:')) return validateSocketEndpoint(uri, ~/ws:\/\/([^\/]+)/, '80', 'WebSocket')
        if (uri.startsWith('netty:')) return validateSocketEndpoint(uri, ~/tcp:\/\/([^:]+):(\d+)/, '8081', 'Netty TCP')
        if (uri.startsWith('mina:')) return validateSocketEndpoint(uri, ~/tcp:\/\/([^:]+):(\d+)/, '8081', 'Mina TCP')
        return "‚ö†Ô∏è Network endpoint type unknown"
    }

    // üîß WALIDACJA GENERYCZNA
    String validateGenericEndpoint(Endpoint endpoint) {
        if (endpoint) {
            return "‚úÖ Endpoint mo≈ºna utworzyƒá: ${endpoint.class.simpleName}"
        } else {
            return "‚ùå Nie mo≈ºna utworzyƒá endpointu"
        }
    }

    // üè∑Ô∏è HELPER METHODS
    String getEndpointType(String uri) {
        return uri.split(':')[0].toLowerCase()
    }

    String extractPath(String uri, String prefix) {
        return uri.substring(prefix.length()).split('\\?')[0]
    }
}

// üéØ KLASA ROUTE Z PRE-VALIDATION
class ValidatedRoutes extends RouteBuilder {

    void configure() {

        // üîß ZA≈ÅADUJ KONFIGURACJƒò Z .env
        EnvConfigLoader.loadEnvFile()

        // üìã ENDPOINTY Z WYKORZYSTANIEM ZMIENNYCH ≈öRODOWISKOWYCH
        def endpointsToValidate = [
            "file:\${INPUT_DIR:/tmp/input}?noop=true",
            "file:\${OUTPUT_DIR:/tmp/output}",
            "file:\${ERROR_DIR:/tmp/error}?autoCreate=true",
            "http://\${API_HOST:httpbin.org}/status/200",
            "https://\${EXTERNAL_API:api.github.com}",
            "smtp://\${SMTP_HOST:localhost}:\${SMTP_PORT:25}",
            "ftp://\${FTP_HOST:localhost}:\${FTP_PORT:21}",
            "activemq:\${QUEUE_NAME:queue:test.queue}",
            "kafka:\${KAFKA_HOST:localhost}:\${KAFKA_PORT:9092}",
            "jdbc:\${DB_TYPE:h2}:\${DB_URL:mem:testdb}",
            "mongodb://\${MONGO_HOST:localhost}:\${MONGO_PORT:27017}",
            "redis://\${REDIS_HOST:localhost}:\${REDIS_PORT:6379}"
        ]

        // ‚úÖ WALIDUJ PRZED STARTEM
        def validator = new EndpointValidator(getContext())
        def results = validator.validateAllEndpoints(endpointsToValidate)

        // üìä POKA≈ª WYNIKI
        println "\n" + "="*60
        println "üîç RAPORT WALIDACJI ENDPOINT√ìW"
        println "="*60

        def successCount = 0
        def errorCount = 0

        results.each { uri, result ->
            println "${result} | ${uri}"
            if (result.startsWith("‚úÖ")) successCount++
            else if (result.startsWith("‚ùå")) errorCount++
        }

        println "="*60
        println "üìä PODSUMOWANIE: ‚úÖ ${successCount} OK | ‚ùå ${errorCount} B≈ÅƒòD√ìW"
        println "="*60

        // üö® ZATRZYMAJ JE≈öLI KRYTYCZNE B≈ÅƒòDY
        if (errorCount > 0) {
            def criticalErrors = results.findAll { k, v ->
                v.startsWith("‚ùå") && !k.contains("autoCreate")
            }

            if (criticalErrors.size() > 0) {
                println "üö® ZATRZYMUJƒò - wykryto krytyczne b≈Çƒôdy endpoint√≥w!"
                throw new RuntimeException("Validation failed: ${criticalErrors.keySet()}")
            }
        }

        // üöÄ JE≈öLI OK - DEFINIUJ ROUTES Z ENV VARIABLES
        from("timer:validation?period=\${TIMER_PERIOD:10000}")
        .routeId("health-check")
        .setBody(constant("System OK - endpointy zwalidowane z .env!"))
        .to("log:health?level=\${LOG_LEVEL:INFO}")

        // Route z wykorzystaniem zmiennych ≈õrodowiskowych
        from("file:\${INPUT_DIR:/tmp/input}?noop=true")
        .routeId("file-processor")
        .onException(Exception.class)
            .to("file:\${ERROR_DIR:/tmp/error}")
            .handled(true)
        .end()
        .to("file:\${OUTPUT_DIR:/tmp/output}")
    }
}

// üöÄ URUCHOMIENIE Z WALIDACJƒÑ
try {
    def camelContext = new DefaultCamelContext()
    camelContext.addRoutes(new ValidatedRoutes())
    camelContext.start()
    
    println "\nüéâ System uruchomiony pomy≈õlnie!"
    println "üìÅ Wszystkie endpointy sprawdzone i dzia≈ÇajƒÖ"
    
    // Keep alive
    Thread.sleep(30000)
    camelContext.stop()
    
} catch (Exception e) {
    println "\nüí• B≈ÅƒÑD URUCHOMIENIA: ${e.message}"
    println "üîß Sprawd≈∫ konfiguracjƒô endpoint√≥w i spr√≥buj ponownie"
}

// üí° BONUS: HEALTHCHECK ENDPOINT
// Dodaj to do monitorowania:
/*
from("jetty:http://localhost:8081/health")
.setBody(constant('{"status":"OK","validated_endpoints":true}'))
.setHeader("Content-Type", constant("application/json"))
*/